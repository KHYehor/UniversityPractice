# EventEmitter 
---

**Своими словами, просто и доступно попробую донести суть, все равно советую перечитать и пересмотреть материалы указанные ниже**

### Зачем нужен Обработчик Cобытий и что такое вообще события?
---

Обработчик событий очень хорошо применим для асинхронных операций, к примеру сервер, который ждет request'ов (запросов), расмотрим на его примере:

сервер запустился, что дальше? чего-то он ждет, например пришел ему запрос http'шный с файлов, или какой-то инфой. Это можно сказать событие это надо ~отметить~ обработать, и вот назовем мы это соыбтие 'data' и сделаем специальный для этого обработчик таких вот разных событий, к которому будем обращаться. Пришло сообщение с клиента, говорим нашему обработчику чтобы тот обработал событие 'data' и передаем ему туда же само сообщение.

Что происходит дальше? Обработчик иммет такой интересный метод как .on который подписывает на очень интересную жизнь сервера а конкретнее на это самое событие 'data' и получает аргумент от него (наш запрос) как только то будет нам отправлен из emit. Ну и вставляет он свою функцию(callback) что обработает данный аргумент как ей угодно: занесет куда-то себе в базу данных, изменит и пошлет обратно серверу или к примеру вообще проигнориурет...и да, таких обработчиков на событие можно вешать столько сколько позволяет вам  setMaxListeners(n) (по дефолту их 10). 
Не поверите, но тоже самое и с другими методами тоже крутится, например ошибка произошла или истекло время ожидания или у бабушки Таи молоко убежало (можно самому тоже задавать события и определять их).

Что касается синхронного кода (скорее всего тот который пишите вы) там всё будет плюс минус очевидно и не совсем интересно и понятно зачем это вообще нужно. К примеру есть у вас код который исполняется так
(линейно и последовательно)

   ||
   
   || 1) где здесь мы подписались  
           
   ||
   
   || 2) где-то тут мы сказали что нужно обработать наше событие
   
   ||
   
   || 3) тут мы снова подписались
   
   ||
   
   || 4) и тут тоже...
   
   ||
   
   \/
   \/

И что же будет? В подписке 1 всё сработает великолепно, а вот подписки 3, 4 нет, потому что? очевидно что они еще даже не определены для нашего обработчика. Вы должны это улавливать и понимать(это уже тема асинхронности/синхронности).

Про конкретные методы я расспишу ниже.

### Какие методы есть у обработчика событий:
---

* **on** - подписка на действие, определяем то, что сделаем когда событие произойдет
* **addListener** - тоже самое и что и on
* **once** - подписка на действие, отработает лишь один раз, после будет игнорирование

* **emit** - обработка события, передаем аргументы для функции которая примет их 
   в .on('...', args => (...))

* **eventNames()** - дайте угадаю ... наверное он вернет список всех событий что есть 
   в этом обраточике? именно

* **listenerCount('event')** - вернет общее число подписок на данное событие

* **setMaxListeners(n)** - установит максимальное число подписок, по дефолту это 10

* **getMaxListeners()** - хммм...да! то что вы подумали

* **rawListeners('event')** - вернет массив функций, что срабатывают в подписке на это событие
  callback'и в .on()

* **removeAllListeners('event')** - удалит все обработчики, что подписаны на это событие

* **removeListener('event', callbackFn)** - снимит обработку для данной функции


#### Где это можно прочитать более детально:
---

[Документация rus](https://js-node.ru/site/article?id=22)

[Документация eng](https://nodejs.org/api/events.html#events_asynchronous_vs_synchronous)

[Medium](https://medium.com/devschacht/safia-abdalla-node-module-deep-dive-eventemitter-f2b7954c4760)

[Примеры кода](https://github.com/HowProgrammingWorks/EventEmitter)

[MDN](https://developer.mozilla.org/ru/docs/Web/Guide/Events/Создание_и_вызов_событий)

[ITVDN](https://www.youtube.com/watch?v=owvEts9H440&t=301s)


